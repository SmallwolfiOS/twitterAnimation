1、指针和对象，都是内存块。一个大，一个小。一个在栈中，一个在堆中。

2、iOS中，我们可以生命一个指针，也可以通过alloc获取一块内存。

3、我们可以直接消灭掉一个指针，将其置为nil。但是我们没办法直接消灭一块对象内存。对于对象内存，我们永远只能依靠系统去回收。而什么时候回收，就需要使用苹果为我们提供了“对象所有权”机制。当一个对象没有被任何指针拥有时，这块对象内存将被系统回收。如果，这个对象是你自定义的，需要自己实现dealloc方法。告诉系统你想怎么回收。

4、将一个指针置为nil，并不会告诉系统，它放弃对其所指向对象的所有权。相当于一个人突然死了，但是没立遗嘱告诉别人，他的财产，它不要了。那么，别人都不能动它的财产。所以，当我们不需要一个指针时，我们首先要让它发送release消息，告诉系统，我指向的对象，我以后不用了。再见！此时，这个指针才能死的瞑目。

5、不再使用一个指针时，最好将其设置为nil，避免其成为野指针（即，已经没有对象属于它的指针），相当于一穷二白的人，身无长物，不拥有任何对象。

中间相差438851376个字节，也就是 418.5M 的空间，因为堆地址要小于栈地址，又因为iOS中一个进程的栈区内存只有1M，Mac也只有8M，显然a已经是在堆区了。

    这也证实了：a 在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 __block 关键字的真正作用。

    理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”，这一点至关重要，要不然你如何解释下面这个现象：

 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的

对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的
在 ARC 开启的情况下，将只会有 NSConcreteGlobalBlock 和 NSConcreteMallocBlock 类型的 block。
原本的 NSConcreteStackBlock 的 block 会被 NSConcreteMallocBlock 类型的 block 替代。证明方式是以下代码在 XCode 中，会输出 <__NSMallocBlock__: 0x100109960>。在苹果的 官方文档 中也提到，当把栈中的 block 返回时，不需要调用 copy 方法了。
我个人认为这么做的原因是，由于 ARC 已经能很好地处理对象的生命周期的管理，这样所有对象都放到堆上管理，对于编译器实现来说，会比较方便。

当一个block对象上堆了，他的声明周期就和一个普通的NSObject对象的方法一样了（这个应该是__NSMallocBlock__这个类的设计参考了NSObject对象的设计）

我们都知道内存有堆和栈两个部分，堆在高地址向下走，栈在低地址向上走。系统为每个函数调用生成一个栈的frame，该函数结束后这个frame被弹出去（所谓的LIFO是也）；堆对象的生存不从属于某个函数，即便是创建这个堆对象的函数结束了，堆对象也可以继续存在，因此内存泄漏都是堆对象惹的祸，ObjC里的引用计数就是用来管理堆对象这个东东的。

全局变量 和 全局静态变量 由于作用域在全局，所以在 block 内访问和读写这两类变量和普通函数没什么区别，而 静态变量 作用域在 block 之外，是怎么对它进行读写呢？通过 clang 工具，我们发现原来 静态变量 是通过指针传递，将变量传递到 block 内，所以可以修改变量值。而上篇文章中的外部变量是通过值传递，自然没法对获取到的外部变量进行修改。由此，可以给我们一个启示，当我们需要修改外部变量时，是不是也可以像 静态变量 这样通过指针来修改外部变量的值呢？

Apple 早就为我们准备了这么一个东西 —— “__block”

意思就很明显了，由于 block 字面量是创建在栈内存，通过 objc_retainBlock() 函数拷贝到堆内存，让 tmp 重新指向堆上的 block，然后将 tmp 所指的堆上的 block 作为一个 Objective-C 对象放入 autoreleasepool 里面，从而保证了返回后的 block 仍然可以正确执行。

/************ ARC下编译器手动拷贝block ************/
- (id)getBlockArray
{
int val = 10;
return [[NSArray alloc] initWithObjects:
^{NSLog(@"blk0:%d", val);},
^{NSLog(@"blk1:%d", val);}, nil];
}
一个例子就了然，返回的数组里面的 block 是不可用的，需要再手动拷贝一次才可以，这个较为简单，就不作过多解释。


没有__block标记的变量，其值会被复制一份到block私有内存区
有__block标记的变量，其地址会被记录在block私有内存区

Block内部使用外部的一个对象，如果外部对象是强引用那么内部会自动生成一个强引用，引用着外部对象。如果外部对象是弱引用那么内部会自动生成一个弱引用，引用着外部对象。

.(weak与strong)不同的是：当一个对象不再有strong类型的指针指向它的时候，它就会被释放，即使改对象还有_weak类型的指针指向它；

一旦最后一个指向该对象的strong类型的指针离开，这个对象将被释放，如果这个时候还有weak指针指向该对象，则会清除掉所有剩余的weak指针

ARC 是编译器特性，而不是 iOS 运行时特性(除了weak指针系统)，它也不是类似于其它语言中的垃圾收集器。因此 ARC 和手动内存管理性能是一样的，有时还能更加快速，因为编译器还可以执行某些优化
ARC 的规则非常简单：只要还有一个变量指向对象，对象就会保持在内存中。当指针指向新值,或者指针不再存在时,相关联的对象就会自动释放。这条规则对于实例变量、synthesize属性、局部变量都是适用的

小提示：当然一般来说在dispatch_async()中你不必担心会有循环引用，因为self并不会持有dispatch_async()的block，所以上述的代码中并不会真的导致循环引用，如果你的闭包并不是很注重结果的，那么self为nil闭包就不会再执行，这个还是挺有用的。
